#!/usr/bin/env bash
set -e -o pipefail

ARGS_FILE="${repo_dir:?}/config/ARGS"
PACKAGES_INSTALL_FILE="${repo_dir:?}/config/PACKAGES_INSTALL"
PACKAGES_REMOVE_FILE="${repo_dir:?}/config/PACKAGES_REMOVE"

args_file_as_build_args_for_github() {
    while IFS="=" read -r key value; do
        echo "$key=$value"
    done < ${ARGS_FILE:?}
}

args_file_as_build_args_for_dockerflags() {
    local prefix="--build-arg "
    while IFS="=" read -r key value; do
        echo -n "${prefix}$key=\"$value\" "
    done < ${ARGS_FILE:?}
}

packages_from_file_with_version() {
    local packages_file="${1:?}"
    while IFS="=" read -r key value; do
        echo -n "$key=$value "
    done < "${packages_file:?}"
}

packages_from_file() {
    local packages_file="${1:?}"
    while IFS="=" read -r key value; do
        echo -n "$key "
    done < "${packages_file:?}"
}

github_env_dump() {
    args_file_as_build_args_for_github
    if [ -f "${PACKAGES_INSTALL_FILE:?}" ]; then
        echo "PACKAGES_TO_INSTALL=$(packages_from_file_with_version "${PACKAGES_INSTALL_FILE:?}")"
    fi
    if [ -f "${PACKAGES_REMOVE_FILE:?}" ]; then
        echo "PACKAGES_TO_REMOVE=$(packages_from_file "${PACKAGES_REMOVE_FILE:?}")"
    fi
}

github_output_build_args() {
    local output=$(github_env_dump)
    if [ -n "${GITHUB_OUTPUT}" ]; then
        echo "build_args<<EOF" >> ${GITHUB_OUTPUT:?}
        echo "${output:?}" >> ${GITHUB_OUTPUT:?}
        echo "EOF" >> ${GITHUB_OUTPUT:?}
    else
        # Convert the build args into a multi-line format
        # that will be accepted by Github workflows.
        output="${output//'%'/'%25'}"
        output="${output//$'\n'/'%0A'}"
        output="${output//$'\r'/'%0D'}"
        echo -e "::set-output name=build_args::${output:?}"
    fi
}

dockerflags_output_build_args() {
    # --build-arg format used with the docker build command.
    args_file_as_build_args_for_dockerflags
    if [ -f "${PACKAGES_INSTALL_FILE:?}" ]; then
        echo -n "--build-arg PACKAGES_TO_INSTALL=\"$(packages_from_file_with_version "${PACKAGES_INSTALL_FILE:?}")\" "
    fi
    if [ -f "${PACKAGES_REMOVE_FILE:?}" ]; then
        echo -n "--build-arg PACKAGES_TO_REMOVE=\"$(packages_from_file "${PACKAGES_REMOVE_FILE:?}")\""
    fi
}

get_config_arg() {
    local key="${1:?}"
    sed -n -E "s/^${key:?}=(.*)\$/\\1/p" ${ARGS_FILE:?}
}

set_config_arg() {
    local key="${1:?}"
    local val="${2:?}"
    sed -i -E "s/^${key:?}=(.*)\$/${key:?}=${val:?}/" ${ARGS_FILE:?}
}

image_name_from_config_key_prefix() {
    local prefix="${1:?}"
    local img_name="$(get_config_arg "${prefix:?}_NAME")"
    local img_tag="$(get_config_arg "${prefix:?}_TAG")"
    echo -n "${img_name:?}:${img_tag:?}"
}

upstream_image_name() {
    image_name_from_config_key_prefix "${UPSTREAM_IMAGE_CONFIG_KEY_PREFIX:?}"
}

package_versions_for_packages_in_packages_install_cmd() {
    echo -n "apt-get -qq update && apt list 2>/dev/null $(packages_from_file "${PACKAGES_INSTALL_FILE:?}") | sed -E 's@([^ ]+)/[^ ]+ ([^ ]+) .+@\1=\2@g'"
}

update_packages_install() {
    if [ -f "${PACKAGES_INSTALL_FILE:?}" ]; then
        updated_list=$(docker run --rm "$(upstream_image_name)" sh -c "$(package_versions_for_packages_in_packages_install_cmd)" | grep -v 'Listing...')
        echo "${updated_list:?}" > "${PACKAGES_INSTALL_FILE:?}"
    else
        echo "No ${PACKAGES_INSTALL_FILE:?} found, so skipping ..."
    fi
}
