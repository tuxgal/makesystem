#!/usr/bin/env bash
set -e -o pipefail

ARGS_FILE="${repo_dir:?}/config/ARGS"
PACKAGES_INSTALL_FILE="${repo_dir:?}/config/PACKAGES_INSTALL"
PACKAGES_REMOVE_FILE="${repo_dir:?}/config/PACKAGES_REMOVE"

args_file_as_build_args_for_github() {
    while IFS="=" read -r key value; do
        echo "$key=$value"
    done < ${ARGS_FILE:?}
}

args_file_as_build_args_for_dockerflags() {
    local prefix="--build-arg "
    while IFS="=" read -r key value; do
        echo -n "${prefix}$key=\"$value\" "
    done < ${ARGS_FILE:?}
}

packages_from_file_with_version() {
    local packages_file="${1:?}"
    while IFS="=" read -r key value; do
        echo -n "$key=$value "
    done < "${packages_file:?}"
}

packages_from_file() {
    local packages_file="${1:?}"
    while IFS="=" read -r key value; do
        echo -n "$key "
    done < "${packages_file:?}"
}

github_env_dump() {
    args_file_as_build_args_for_github
    if [ -f "${PACKAGES_INSTALL_FILE:?}" ]; then
        echo "PACKAGES_TO_INSTALL=$(packages_from_file_with_version "${PACKAGES_INSTALL_FILE:?}")"
    fi
    if [ -f "${PACKAGES_REMOVE_FILE:?}" ]; then
        echo "PACKAGES_TO_REMOVE=$(packages_from_file "${PACKAGES_REMOVE_FILE:?}")"
    fi
}

github_output_build_args() {
    local output=$(github_env_dump)
    if [ -n "${GITHUB_OUTPUT}" ]; then
        echo "build_args<<EOF" >> ${GITHUB_OUTPUT:?}
        echo "${output:?}" >> ${GITHUB_OUTPUT:?}
        echo "EOF" >> ${GITHUB_OUTPUT:?}
    else
        # Convert the build args into a multi-line format
        # that will be accepted by Github workflows.
        output="${output//'%'/'%25'}"
        output="${output//$'\n'/'%0A'}"
        output="${output//$'\r'/'%0D'}"
        echo -e "::set-output name=build_args::${output:?}"
    fi
}

dockerflags_output_build_args() {
    # --build-arg format used with the docker build command.
    args_file_as_build_args_for_dockerflags
    if [ -f "${PACKAGES_INSTALL_FILE:?}" ]; then
        echo -n "--build-arg PACKAGES_TO_INSTALL=\"$(packages_from_file_with_version "${PACKAGES_INSTALL_FILE:?}")\" "
    fi
    if [ -f "${PACKAGES_REMOVE_FILE:?}" ]; then
        echo -n "--build-arg PACKAGES_TO_REMOVE=\"$(packages_from_file "${PACKAGES_REMOVE_FILE:?}")\""
    fi
}

get_config_value_from_file() {
    local config_file="${1:?}"
    local key="${2:?}"
    sed -n -E "s/^${key:?}=(.*)\$/\\1/p" ${config_file:?}
}

set_config_value_in_file() {
    local config_file="${1:?}"
    local key="${2:?}"
    local val="${3:?}"
    sed -i -E "s/^${key:?}=(.*)\$/${key:?}=${val:?}/" ${config_file:?}
}

get_config_arg() {
    local key="${1:?}"
    get_config_value_from_file "${ARGS_FILE:?}" "${key:?}"
}

set_config_arg() {
    local key="${1:?}"
    local val="${2:?}"
    set_config_value_in_file "${ARGS_FILE:?}" "${key:?}" "${val:?}"
}

get_packages_install_package_version() {
    local pkg="${1:?}"
    get_config_value_from_file "${PACKAGES_INSTALL_FILE:?}" "${pkg:?}"
}

image_name_from_config_key_prefix() {
    local prefix="${1:?}"
    local img_name="$(get_config_arg "${prefix:?}_NAME")"
    local img_tag="$(get_config_arg "${prefix:?}_TAG")"
    echo -n "${img_name:?}:${img_tag:?}"
}

upstream_image_name() {
    image_name_from_config_key_prefix "${UPSTREAM_IMAGE_CONFIG_KEY_PREFIX:?}"
}

package_version_cmd() {
    local pkg="${1:?}"
    echo -n "apt-get -qq update && apt list 2>/dev/null ${pkg:?} | grep '${pkg:?}' | sed -E 's@([^ ]+)/[^ ]+ ([^ ]+) .+@\2@g'"
}

package_versions_for_packages_in_packages_install_cmd() {
    echo -n "apt-get -qq update && apt list 2>/dev/null $(packages_from_file "${PACKAGES_INSTALL_FILE:?}") | sed -E 's@([^ ]+)/[^ ]+ ([^ ]+) .+@\1=\2@g'"
}

update_packages_install() {
    if [ -f "${PACKAGES_INSTALL_FILE:?}" ]; then
        updated_list=$(docker run --rm "$(upstream_image_name)" sh -c "$(package_versions_for_packages_in_packages_install_cmd)" | grep -v 'Listing...')
        echo "${updated_list:?}" > "${PACKAGES_INSTALL_FILE:?}"
    else
        echo "No ${PACKAGES_INSTALL_FILE:?} found, so skipping ..."
    fi
}

test_random_container_name() {
    shuf -zer -n16  _ {A..Z} {a..z} {0..9} | tr -d '\0'
}

test_cleanup_container() {
    local container_name="${1:?}"

    echo "Stopping the ${TEST_CONTAINER_TYPE:?} container ${container_name:?} ..."
    docker stop ${container_name:?} --time 5 2>/dev/null 1>&2 || /bin/true
    docker kill ${container_name:?} 2>/dev/null 1>&2 || /bin/true
}

run_test() {
    local container_name=$(test_random_container_name)

    if [[ "${TEST_TYPE}" == "background" ]]; then
        echo "Starting ${TEST_CONTAINER_TYPE:?} container ${container_name:?} to run tests in the background ..."
        test_start_container ${container_name:?}

        echo "Waiting for the ${TEST_CONTAINER_TYPE:?} container ${container_name:?} to finish starting up ..."
        sleep ${TEST_CONTAINER_START_WAIT_SECONDS}

        echo "Running tests against the ${TEST_CONTAINER_TYPE:?} container ${container_name:?} ..."
        test_image_after_container_startup ${container_name:?}

        echo "All tests passed against the ${TEST_CONTAINER_TYPE:?} container ${container_name:?} ..."
        test_cleanup_container ${container_name:?}
    elif [[ "${TEST_TYPE}" == "foreground" ]]; then
        echo "Starting ${TEST_CONTAINER_TYPE:?} container ${container_name:?} to run tests in the foreground ..."
        test_start_container ${container_name:?}
        echo "All tests passed against the ${TEST_CONTAINER_TYPE:?} container ${container_name:?} ..."
    else
        echo "Invalid value for TEST_TYPE=${TEST_TYPE:?}"
        exit 1
    fi
}

git_repo_get_all_tags() {
    local git_repo="${1:?}"

    if [ -z "$GIT_REPO_TAGS_CUSTOM_FILTERING_REGEX" ]; then
        git -c 'versionsort.suffix=-' ls-remote \
            --exit-code \
            --refs \
            --sort='version:refname' \
            --tags \
            ${git_repo:?} '*.*.*' | \
            cut --delimiter='/' --fields=3
    else
        git -c 'versionsort.suffix=-' ls-remote \
            --exit-code \
            --refs \
            --sort='version:refname' \
            --tags \
            ${git_repo:?} '*.*.*' | \
            cut --delimiter='/' --fields=3 | \
            grep -P -v "${GIT_REPO_TAGS_CUSTOM_FILTERING_REGEX:?}"
    fi
}

git_repo_latest_tag() {
    git_repo="${1:?}"
    # Strip out any strings that begin with 'v' before identifying the highest semantic version.
    highest_sem_ver_tag=$(git_repo_get_all_tags ${git_repo:?} | sed -E s'#^v(.*)$#\1#g' | sed '/-/!{s/$/_/}' | sort --version-sort | sed 's/_$//'| tail -1)
    # Identify the correct tag for the semantic version of interest.
    git_repo_get_all_tags ${git_repo:?} | grep -E "${highest_sem_ver_tag//./\\.}$" | cut --delimiter='/' --fields=3
}

dockerhub_tags() {
    local dockerhub_repo="${1:?}"
    case "${dockerhub_repo:?}" in
        */*) :;; # namespace/repository syntax, leave as is
        *) dockerhub_repo="library/${dockerhub_repo:?}";; # bare repository name (docker official image); must convert to namespace/repository syntax
    esac
    auth_url="https://auth.docker.io/token?service=registry.docker.io&scope=repository:${dockerhub_repo:?}:pull"
    token="$(curl -fsSL "${auth_url:?}" | jq --raw-output '.token')"
    tags_url="https://registry-1.docker.io/v2/${dockerhub_repo:?}/tags/list"
    curl -fsSL -H "Accept: application/json" -H "Authorization: Bearer ${token:?}" "${tags_url:?}" | jq --raw-output '.tags[]'
}

dockerhub_latest_tag() {
    local repo="${1:?}"
    local img_pattern="${2:?}"
    dockerhub_tags "${repo:?}" | grep -E "${img_pattern:?}" | sort --version-sort --reverse | head -1
}

url_sha256_checksum() {
    local url="${1:?}"
    curl --silent --location ${url:?} | sha256sum | cut --delimiter=' ' --fields=1
}

upstream_git_repo_archive_sha256_checksum() {
    local ver="${1:?}"
    url_sha256_checksum "${UPSTREAM_GIT_REPO:?}/archive/refs/tags/${ver:?}.tar.gz"
}

update_latest_upstream() {
    local cur_ver="$(current_upstream_version)"
    local latest_ver="$(latest_upstream_version)"

    if [[ "${cur_ver:?}" == "${latest_ver:?}" ]]; then
        echo "Existing config is already up to date and pointing to the latest upstream ${PACKAGE_NAME:?} version '${latest_ver:?}'"
    else
        update_latest_upstream_version "${cur_ver:?}" "${latest_ver:?}"
        git commit -m "feat: Bump upstream ${PACKAGE_NAME:?} version to ${latest_ver:?}."
    fi
}
